###########
# FUNCTIONS
###########
rm(list=ls())
options(stringsAsFactors = FALSE) 
multipleCombine <- function(input, ply = llply){
  require(plyr)
  require(dplyr)
  ply(input, function(x){
    t <- read.table(x, header=TRUE, sep=",",stringsAsFactors = FALSE) # read the csv
    t1 <- rbind(t) # rbind it to a temporary variable
    return(t1) # return the full variable
  }
  )
}
###########
# LIBRARIES
###########
library(plyr)
library(dplyr)

##############
# LOADING DATA
##############
# The data in this github repository was downloaded on 8/7/2015
# Replace 'pathToData' with the location of the carabid data downloaded from NEON's web portal
pathToData <- 'C:/Users/klevan/Documents/GitHub/carabid-workshop/data/portal download'
pathToWeatherData <- 'C:/Users/klevan/Documents/GitHub/carabid-workshop/data'
setwd(pathToData)

# Suffixes of the 3 data tables generated by NEON Carabid Sampling
# See the following link for details about the protocol: http://data.neoninc.org/documents?p_p_id=110_INSTANCE_JEygRkSpUBoq&p_p_lifecycle=0&p_p_state=normal&p_p_mode=view&p_p_col_id=column-1&p_p_col_count=1&_110_INSTANCE_JEygRkSpUBoq_struts_action=%2Fdocument_library_display%2Fview_file_entry&_110_INSTANCE_JEygRkSpUBoq_redirect=http%3A%2F%2Fdata.neoninc.org%2Fdocuments%2F-%2Fdocument_library_display%2FJEygRkSpUBoq%2Fview%2F1883155%3F_110_INSTANCE_JEygRkSpUBoq_redirect%3Dhttp%253A%252F%252Fdata.neoninc.org%252Fdocuments%253Fp_p_id%253D110_INSTANCE_JEygRkSpUBoq%2526p_p_lifecycle%253D0%2526p_p_state%253Dnormal%2526p_p_mode%253Dview%2526p_p_col_id%253Dcolumn-1%2526p_p_col_count%253D1&_110_INSTANCE_JEygRkSpUBoq_fileEntryId=1663903
field <- 'bet_fielddata.csv' # Data that is recorded in the field when samples are recovered from pitfall traps
sort <- 'bet_sorting.csv' # Data recorded in the lab during an initial sort; data on vertebrate and invertebrate bycatch is recorded in this table; data on carabids that were not pinned is recorded here
pin <- 'bet_IDandpinning.csv' # Data on identified carabids that were pinned; many of these Carabids will eventually be available for loan from archival facilities
weather <- 'NOAA weather data for 2014.csv'

# This function will grab the file paths of all the data in the folder
fileList <- list.files(pathToData, full.names=TRUE) # list all the files, full.names=TRUE is necessary for ldplay/lapply to work below
field <- fileList[grep(field,fileList)] # subset to just the ones in your module, using prefix, if needed
sort <- fileList[grep(sort,fileList)] # subset to just the ones in your module, using prefix, if needed
pin <- fileList[grep(pin,fileList)] # subset to just the ones in your module, using prefix, if needed

fileList <- list.files(pathToWeatherData, full.names=TRUE) # list all the files, full.names=TRUE is necessary for ldplay/lapply to work below
weather <- fileList[grep(weather,fileList)]
weather <- read.table(weather, header=TRUE, sep=",",stringsAsFactors = FALSE); weather[,c(8,12:14)] <- weather[,c(8,12:14)]/10;weather$DATE <- paste(substr(weather$DATE,1,4),substr(weather$DATE,5,6),substr(weather$DATE,7,8),sep = '-') ;weather$DATE <- as.Date(weather$DATE,format="%Y-%m-%d")

# Three dataframes compiling all the NEON data are created below
bet_field = multipleCombine(field, ply = ldply) # The field data from all sites
bet_sort = multipleCombine(sort, ply = ldply) # The sorting data from all sites
bet_pin = multipleCombine(pin, ply = ldply) # The data on pinned Carabidae

gisData <- unique.data.frame(bet_field[c("domainID","siteID","plotID","trapID","nlcdClass",
                                         "decimalLatitude","decimalLongitude","geodeticDatum",
                                         "coordinateUncertainty","elevation","elevationUncertainty")])
bet_field %>% filter(missingRecordsPerBoutQF==0) %>% select(-missingRecordsPerBoutQF)->bet_field # These are misleading. If FOPS didn't set a trap, it isn't in any table
rm(field,sort,pin,fileList)
###########################
# FIXING ERRORS IN THE DATA
###########################
# Errors in bet_field
#####################
# Resolving duplicates
for (i in 1:dim(bet_field)[1]){
  if(bet_field$plotID[i]=="JERC_030" & bet_field$boutNumber[i]==3) {
    bet_field$setDate[i] <- "2014-07-02"
    bet_field$collectDate[i] <- "2014-07-16"
  }
}
# Standardizing sampleID
for (i in 1:dim(bet_field)[1]){
  bet_field$sampleID[i] <- paste(bet_field$plotID[i],bet_field$trapID[i],
                                 paste0(unlist(strsplit(as.character(bet_field$collectDate[i]),split="-"))[1],
                                        unlist(strsplit(as.character(bet_field$collectDate[i]),split="-"))[2],
                                        unlist(strsplit(as.character(bet_field$collectDate[i]),split="-"))[3]),
                                 sep = '.')
}
# Removing uid and duplicate record
bet_field <- bet_field[-927,2:26]

# Handling remarks
a <- sort(unique(unlist(strsplit(bet_field$remarks,split = ' ')))); a <- a[c(3:4,6,38,40,60:61,85,136:137,146:147,180,192:194,344:347,372,467,479,484:486,497,503)]
events <- c(rep("flooded",3),rep('animal',5),rep('debris',2),
            rep('animal',2),'landUse',rep('flooded',14),'animal')
remarkList <- as.data.frame(cbind(a,events))
rm(a,events)
bet_field$remarkType <- ''
for (i in 1:dim(bet_field)[1]){
  if(nchar(bet_field$remarks[i])>0){
    for (j in 1:length(unlist(strsplit(bet_field$remarks[i],split=" ")))){
      remarkList %>% 
        filter(a==unlist(strsplit(bet_field$remarks[i],split=" "))[j])-> x
      if (dim(x)[1]>0){
        bet_field$remarkType[i] <- remarkList$event[match(unlist(strsplit(bet_field$remarks[i],split=" "))[j],remarkList$a)]
      }
    }   
  }
}
rm(remarkList,x)

# Errors in bet_sort 
####################
# Make sampleIDs all Caps
bet_sort$associatedSampleID <- toupper(bet_sort$associatedSampleID)
# Known uids that are complete duplicates for bycatch
uidToRemove <- c("ED7318A8BAEB438684E8F09EAABE185F","F6C95A226CE747B4A628C9D11EB07730","2C716CDD2DAC4173AA853257EC522B1E",
                 "3867CCADDB344AA28A72E8188D1CA6A8","6650FC14AD64406BACA54D6E57862C7F","EDD0884075574497BCFC281B7B58E50C")
# Finding additional records that are duplicated in invert bycatch
bet_sort %>% 
  filter(duplicateSampleIDQF==2,sampleType=="invert bycatch") -> a
for(i in unique(a$sampleID)){
  a %>% 
    filter(sampleID==i)-> a1
  uidToRemove <- append(uidToRemove,a1$uid[2])
}
# Finding records that are duplicates in the common carabid group
bet_sort %>% 
  filter(duplicateSampleIDQF==2,sampleType=="common carabid") -> a
a <- a[11:42,]
for(i in unique(a$associatedSampleID)){
  a %>% 
    filter(associatedSampleID==i) -> a1
  a1 %>% filter(individualCount==a1$individualCount) -> a1
  uidToRemove <- append(uidToRemove,a1$uid)
}
rm(a,a1)
# Remove duplicates
bet_sort <- bet_sort[-match(uidToRemove,bet_sort$uid),2:dim(bet_sort)[2]]

# Adding individual count numbers for records missing that data; fixing dates
for (i in 1:dim(bet_sort)[1]){
  if(bet_sort$sampleType[i]=='vert bycatch mam' & is.na(bet_sort$individualCount[i])==TRUE){
    bet_sort$individualCount[i] <- 1
  }
  if(bet_sort$sampleType[i]=='vert bycatch herp' & is.na(bet_sort$individualCount[i])==TRUE){
    bet_sort$individualCount[i] <- 1
  }
  if(length(unlist(strsplit(bet_sort$collectDate[i],split = '/')))==3){
    bet_sort$collectDate[i] <- paste(unlist(strsplit(bet_sort$collectDate[i],split = '/'))[3],
                                     ifelse(nchar(unlist(strsplit(bet_sort$collectDate[i],split = '/'))[1])==2,
                                            unlist(strsplit(bet_sort$collectDate[i],split = '/'))[1],
                                            paste0(0,unlist(strsplit(bet_sort$collectDate[i],split = '/'))[1])),
                                     ifelse(nchar(unlist(strsplit(bet_sort$collectDate[i],split = '/'))[2])==2,
                                            unlist(strsplit(bet_sort$collectDate[i],split = '/'))[2],
                                            paste0(0,unlist(strsplit(bet_sort$collectDate[i],split = '/'))[2])),
                                     sep = '-')
  }
  if(length(unlist(strsplit(bet_sort$etOHChangeDate[i],split = '/')))==3){
    bet_sort$etOHChangeDate[i] <- paste(unlist(strsplit(bet_sort$etOHChangeDate[i],split = '/'))[3],
                                        ifelse(nchar(unlist(strsplit(bet_sort$etOHChangeDate[i],split = '/'))[1])==2,
                                               unlist(strsplit(bet_sort$etOHChangeDate[i],split = '/'))[1],
                                               paste0(0,unlist(strsplit(bet_sort$etOHChangeDate[i],split = '/'))[1])),
                                        ifelse(nchar(unlist(strsplit(bet_sort$etOHChangeDate[i],split = '/'))[2])==2,
                                               unlist(strsplit(bet_sort$etOHChangeDate[i],split = '/'))[2],
                                               paste0(0,unlist(strsplit(bet_sort$etOHChangeDate[i],split = '/'))[2])),
                                        sep = '-')
  }
  if(length(unlist(strsplit(bet_sort$processingDate[i],split = '/')))==3){
    bet_sort$processingDate[i] <- paste(unlist(strsplit(bet_sort$processingDate[i],split = '/'))[3],
                                        ifelse(nchar(unlist(strsplit(bet_sort$processingDate[i],split = '/'))[1])==2,
                                               unlist(strsplit(bet_sort$processingDate[i],split = '/'))[1],
                                               paste0(0,unlist(strsplit(bet_sort$processingDate[i],split = '/'))[1])),
                                        ifelse(nchar(unlist(strsplit(bet_sort$processingDate[i],split = '/'))[2])==2,
                                               unlist(strsplit(bet_sort$processingDate[i],split = '/'))[2],
                                               paste0(0,unlist(strsplit(bet_sort$processingDate[i],split = '/'))[2])),
                                        sep = '-')
  }
  if(length(unlist(strsplit(bet_sort$identifiedDate[i],split = '/')))==3){
    bet_sort$identifiedDate[i] <- paste(unlist(strsplit(bet_sort$identifiedDate[i],split = '/'))[3],
                                        ifelse(nchar(unlist(strsplit(bet_sort$identifiedDate[i],split = '/'))[1])==2,
                                               unlist(strsplit(bet_sort$identifiedDate[i],split = '/'))[1],
                                               paste0(0,unlist(strsplit(bet_sort$identifiedDate[i],split = '/'))[1])),
                                        ifelse(nchar(unlist(strsplit(bet_sort$identifiedDate[i],split = '/'))[2])==2,
                                               unlist(strsplit(bet_sort$identifiedDate[i],split = '/'))[2],
                                               paste0(0,unlist(strsplit(bet_sort$identifiedDate[i],split = '/'))[2])),
                                        sep = '-')
  }
}


bet_sort$sampleIDPLUStaxa <- substr(bet_sort$sampleID,1,nchar(bet_sort$sampleID)-3)

# Errors in the bet_pin
#######################
bet_pin$individualCount <-  1 # The pinning table represents single instances of individuals
# Make sampleIDs all Caps
bet_pin$sampleID <- toupper(bet_pin$sampleID)
# Fixing dates
for (i in 1:dim(bet_pin)[1]){
  if(length(unlist(strsplit(bet_pin$collectDate[i],split = '/')))==3){
    bet_pin$collectDate[i] <- paste(unlist(strsplit(bet_pin$collectDate[i],split = '/'))[3],
                                    ifelse(nchar(unlist(strsplit(bet_pin$collectDate[i],split = '/'))[1])==2,
                                           unlist(strsplit(bet_pin$collectDate[i],split = '/'))[1],
                                           paste0(0,unlist(strsplit(bet_pin$collectDate[i],split = '/'))[1])),
                                    ifelse(nchar(unlist(strsplit(bet_pin$collectDate[i],split = '/'))[2])==2,
                                           unlist(strsplit(bet_pin$collectDate[i],split = '/'))[2],
                                           paste0(0,unlist(strsplit(bet_pin$collectDate[i],split = '/'))[2])),
                                    sep = '-')
  }
  if(length(unlist(strsplit(bet_pin$processingDate[i],split = '/')))==3){
    bet_pin$processingDate[i] <- paste(unlist(strsplit(bet_pin$processingDate[i],split = '/'))[3],
                                       ifelse(nchar(unlist(strsplit(bet_pin$processingDate[i],split = '/'))[1])==2,
                                              unlist(strsplit(bet_pin$processingDate[i],split = '/'))[1],
                                              paste0(0,unlist(strsplit(bet_pin$processingDate[i],split = '/'))[1])),
                                       ifelse(nchar(unlist(strsplit(bet_pin$processingDate[i],split = '/'))[2])==2,
                                              unlist(strsplit(bet_pin$processingDate[i],split = '/'))[2],
                                              paste0(0,unlist(strsplit(bet_pin$processingDate[i],split = '/'))[2])),
                                       sep = '-')
  }
  if(length(unlist(strsplit(bet_pin$identifiedDate[i],split = '/')))==3){
    bet_pin$identifiedDate[i] <- paste(unlist(strsplit(bet_pin$identifiedDate[i],split = '/'))[3],
                                       ifelse(nchar(unlist(strsplit(bet_pin$identifiedDate[i],split = '/'))[1])==2,
                                              unlist(strsplit(bet_pin$identifiedDate[i],split = '/'))[1],
                                              paste0(0,unlist(strsplit(bet_pin$identifiedDate[i],split = '/'))[1])),
                                       ifelse(nchar(unlist(strsplit(bet_pin$identifiedDate[i],split = '/'))[2])==2,
                                              unlist(strsplit(bet_pin$identifiedDate[i],split = '/'))[2],
                                              paste0(0,unlist(strsplit(bet_pin$identifiedDate[i],split = '/'))[2])),
                                       sep = '-')
  }
}

# Correcting sampleIDs
# Set aside things that are completely accurate
matches <- (bet_pin$sampleID %in% bet_sort$associatedSampleID); bet_pin <- cbind(bet_pin,matches)
bet_pin %>% filter(matches==TRUE) -> bet_pin1; bet_pin1 <- bet_pin1[,-match('matches',colnames(bet_pin1))] # 3778  correct records
bet_pin %>% filter(matches==FALSE) -> bet_pin; bet_pin <- bet_pin[,-match('matches',colnames(bet_pin))] # 2168 incorrect records

# Adding a tube number '01' shows it exists
bet_pin$sampleID2 <- paste(bet_pin$sampleID,'01',sep=".")
matches <- (bet_pin$sampleID2 %in% bet_sort$associatedSampleID); bet_pin <- cbind(bet_pin,matches)
bet_pin %>% filter(matches==TRUE) -> bet_pin2; bet_pin2$sampleID <- bet_pin2$sampleID2 # 998 correct records
bet_pin2 <- bet_pin2[,-match('matches',colnames(bet_pin2))]; bet_pin2 <- bet_pin2[,-match('sampleID2',colnames(bet_pin2))]; bet_pin1 <- rbind(bet_pin1,bet_pin2); rm(bet_pin2)
bet_pin %>% filter(matches==FALSE) -> bet_pin; bet_pin <- bet_pin[,-match('matches',colnames(bet_pin))]; bet_pin <- bet_pin[,-match('sampleID2',colnames(bet_pin))] # 1170 incorrect records left to fix


# Of the sampleIDs that don't have a match in the sort table
for (i in bet_pin$individualID){
  bet_sort %>% 
    filter(plotID==bet_pin$plotID[match(i,bet_pin$individualID)],
           trapID==bet_pin$trapID[match(i,bet_pin$individualID)],
           collectDate==bet_pin$collectDate[match(i,bet_pin$individualID)],
           sampleType!='vert bycatch mam',
           sampleType!='vert bycatch herp',
           sampleType!='invert bycatch') -> b
  # Nothing in the sort table matches the plot/trap/date combo
  if(dim(b)[1]==0){
    bet_pin$sampleID2[match(i,bet_pin$individualID)] <- ''
  }
  
  # Only one option in the sort table
  if(dim(b)[1]==1){
    bet_pin$sampleID2[match(i,bet_pin$individualID)] <- b$associatedSampleID[1]
  }
  
  # Many options in the sort table
  if(dim(b)[1]>1){
    # And the pinned specimen was a 'common carabid' with a taxonID in the sample ID
    bet_sort %>% 
      filter(sampleIDPLUStaxa==paste(bet_pin$plotID[match(i,bet_pin$individualID)],
                                     bet_pin$trapID[match(i,bet_pin$individualID)],
                                     substr(bet_pin$sampleID[match(i,bet_pin$individualID)],12,19),
                                     bet_pin$taxonID[match(i,bet_pin$individualID)],
                                     sep='.')) -> b1
    if(dim(b1)[1]>0){
      bet_pin$sampleID2[match(i,bet_pin$individualID)] <- b1$associatedSampleID[1]
    } else{
      # And the pinned specimen was a 'common carabid' given a morphospecies assignment 
      bet_sort %>% 
        filter(substr(sampleID,1,19)==paste(bet_pin$plotID[match(i,bet_pin$individualID)],
                                            bet_pin$trapID[match(i,bet_pin$individualID)],
                                            substr(bet_pin$sampleID[match(i,bet_pin$individualID)],12,19),
                                            sep='.'),
               morphospeciesID==bet_pin$morphospeciesID[match(i,bet_pin$individualID)],nchar(morphospeciesID)>0) -> b1
      if(dim(b1)[1]>0){
        bet_pin$sampleID2[match(i,bet_pin$individualID)] <- b1$associatedSampleID[1]
      } else{
        # An 'other carabid' exists that fits the bill
        bet_sort %>% 
          filter(sampleIDPLUStaxa==paste(bet_pin$plotID[match(i,bet_pin$individualID)],
                                         bet_pin$trapID[match(i,bet_pin$individualID)],
                                         substr(bet_pin$sampleID[match(i,bet_pin$individualID)],12,19),
                                         'OC',
                                         sep='.')) -> b1
        if(dim(b1)[1]>0){
          bet_pin$sampleID2[match(i,bet_pin$individualID)] <- b1$associatedSampleID[1]
        }
      }
    }
  }   
  bet_pin$numRecords[match(i,bet_pin$individualID)] <- dim(b)[1]
  b=0
}
bet_pin %>% filter(numRecords==0)-> bet_pin2 # 213 samples with no provenance in the sort table
bet_pin %>% filter(numRecords>0)-> bet_pin # 957 records that might exist
for (i in 1:dim(bet_pin)[1]){
  if (substr(bet_pin$sampleID[i],1,19)==substr(bet_pin$sampleID2[i],1,19)){
    bet_pin$plausible[i] <- TRUE
  } else {
    bet_pin$plausible[i] <- FALSE    
  }
}
bet_pin %>% filter(plausible==TRUE) -> bet_pin3; bet_pin3$sampleID <- bet_pin3$sampleID2; bet_pin3 <- bet_pin3[,1:23]; bet_pin1 <- rbind(bet_pin1,bet_pin3); rm(bet_pin3) # 561 plausible fixes
bet_pin %>% filter(plausible==FALSE) -> bet_pin # 396 with incorrect sampleIDs

# Are the last incorrect IDs other carabids?
bet_pin$sampleID2 <- paste(substr(bet_pin$sampleID,1,19),'OC.01',sep='.'); bet_pin <- bet_pin[,1:24]
plausible <- bet_pin$sampleID2 %in% bet_sort$associatedSampleID; bet_pin <- cbind(bet_pin,plausible) 
bet_pin %>% filter(plausible==TRUE) -> bet_pin3; bet_pin3$sampleID <- bet_pin3$sampleID2; bet_pin3 <- bet_pin3[,1:23]; bet_pin1 <- rbind(bet_pin1,bet_pin3); rm(bet_pin3) # 313 could have been other carabids
bet_pin %>% filter(plausible==FALSE) -> bet_pin; bet_pin <- bet_pin[,1:23]; bet_pin2 <- bet_pin2[,1:23] # 83 with incorrect sampleIDs

# Some records in the pin table are for 'other carabids'; but were never entered in the sort table
bet_pin <- rbind(bet_pin,bet_pin2); rm(bet_pin2) # All records without sort info
bet_pin$sampleID <- paste(substr(bet_pin$sampleID,1,19),'OC.01',sep=".") 

# Adding missing pinning records into the sort table
bet_sort <- bet_sort[,1:24]
bet_sortExtraRecords <- unique.data.frame(cbind(bet_pin[,c(2:9,12:21,23)],
                                                bet_sort[1:dim(bet_pin)[1],c('associatedSampleID','etOHChangeDate','targetTaxaPresent','sampleType','duplicateSampleIDQF')]))
bet_sortExtraRecords$associatedSampleID <- bet_sortExtraRecords$sampleID; bet_sortExtraRecords$sampleType <- 'other carabid'; bet_sortExtraRecords$targetTaxaPresent <- 'Y'
bet_sortExtraRecords <- bet_sortExtraRecords[,colnames(bet_sort)]; bet_sortExtraRecords[,c(6,8,10,13:24)] <- ''; bet_sortExtraRecords$remarks <- 'record not originally found in sorting data; presumed to exist based on pinning data'
bet_sort <- rbind(bet_sort,unique.data.frame(bet_sortExtraRecords)); rm(bet_sortExtraRecords) # Now sorting table is complete

# Appending fixed pinning records to majority of pinning samples
bet_pin <- rbind(bet_pin,bet_pin1); rm(bet_pin1) # Now pinning data is complete

# Adding missing records
# Records in the pin and sort without corresponding field data
matches <- substr(bet_sort$associatedSampleID,1,19)%in%bet_field$sampleID
bet_sortA <- cbind(bet_sort,matches); bet_sortA %>% filter(matches==FALSE,sampleType!='invert bycatch')->bet_sortA; bet_sortA$sampleID <- substr(bet_sortA$associatedSampleID,1,19)
missingFieldRecords <- unique.data.frame(bet_sortA[c('domainID','siteID',"plotID","trapID","collectDate","sampleID")]); rm(bet_sortA)

fieldRecords <- bet_field[1:dim(missingFieldRecords)[1],]
fieldRecords[,c('uid','setDate',"boutNumber","eventID","daysOfTrapping",
                "cupStatus","lidStatus","fluidLevel","trapReset","remarks",'recordedBy',
                "duplicateCollectionEventQF", "compareSetCollectDateQF")] <- ''
missingFieldRecords <- cbind(missingFieldRecords,fieldRecords[1:dim(missingFieldRecords)[1],c("setDate","boutNumber","eventID","daysOfTrapping","cupStatus","lidStatus","fluidLevel",                
                                                                                              "trapReset","samplingProtocol","recordedBy","remarks",
                                                                                              "duplicateCollectionEventQF","remarkType")])
for (i in 1:dim(missingFieldRecords)[1]){
  gisData %>% 
    filter(plotID==missingFieldRecords$plotID[i],trapID==missingFieldRecords$trapID[i])->a
  missingFieldRecords$nlcdClass[i] <- a$nlcdClass[1]
  missingFieldRecords$decimalLatitude[i] <- a$decimalLatitude[1]
  missingFieldRecords$decimalLongitude[i]<- a$decimalLongitude[1]
  missingFieldRecords$geodeticDatum[i]<- a$geodeticDatum[1]
  missingFieldRecords$coordinateUncertainty[i]<- a$coordinateUncertainty[1]
  missingFieldRecords$elevation[i]<- a$elevation[1]
  missingFieldRecords$elevationUncertainty[i]<- a$elevationUncertainty[1]
}

missingFieldRecords <- missingFieldRecords[colnames(bet_field)]
missingFieldRecords$remarks <- 'This record is assumed to exist based on the presence of sorting or pinning data'
bet_field <- rbind(bet_field,missingFieldRecords);rm(missingFieldRecords,plausible,uidToRemove,gisData,matches,fieldRecords)
for (i in 1:dim(bet_field)[1]){
  if(bet_field$boutNumber[i]!='10' &
     bet_field$boutNumber[i]!='11' & 
     bet_field$boutNumber[i]!=''){
    bet_field$eventID[i] <- paste('BET',bet_field$plotID[i],'2014',paste0(0,bet_field$boutNumber[i]),sep='.')    
  } 
  if(bet_field$boutNumber[i]!='10'& 
     bet_field$boutNumber[i]!='11'){
    bet_field$eventID[i] <- paste('BET',bet_field$plotID[i],'2014',bet_field$boutNumber[i],sep='.')    
  }
}
#########################################
# Compiling Carabid Abundance & Diversity 
#########################################
# Converting collectDate into a date format
bet_field$collectDate <- as.Date(bet_field$collectDate,format="%Y-%m-%d")
bet_sort$individualCount <- as.numeric(bet_sort$individualCount)
bet_field$daysOfTrapping <- as.numeric(bet_field$daysOfTrapping)

# 1) If the sampleType=='common carabid', then the individualCount reflects the true number of Carabids of a given species that were in the trap.
# This means that functionally the 'individualCount' of any 'common carabid' beetle with a sample ID that is not in the pinning table at all 
# can be processed for diversity/abundance as though none were pinned. Pinning records just tell you that a pinned individual from that trap is available
# OR
# 2) If the sampleType=='other carabid' in the bet_sort, then there is at least one beetle present from the trap indicated in the record,
# and to calculate abundance we need to count the number of rows associated with that sampleID

# Getting the 'common carabid' data
bet_sort %>% 
  filter(sampleType=='common carabid')-> bet_cc

for (i in 1:dim(bet_cc)[1]){
  # For sorting data missing counts, check the pinning table for records.
  if(is.na(bet_cc$individualCount[i])==TRUE){
    bet_pin %>% 
      filter(plotID==bet_cc$plotID[i],trapID==bet_cc$trapID[i],
             collectDate==bet_cc$collectDate[i],taxonID==bet_cc$taxonID[i])-> a
    if(dim(a)[1]>0){
      bet_cc$individualCount[i] <- dim(a)[1]
    }
  }
  # For sorting data missing counts in the pinning table entirely, assign a minimum count of 1
  if(is.na(bet_cc$individualCount[i])==TRUE){ 
    bet_cc$individualCount[i] <- 1
  }
}

# Filling in other carabid data
bet_sort %>% 
  filter(sampleType=='other carabid') -> bet_oc
for (i in 1:dim(bet_oc)[1]){
  bet_pin %>% 
    filter(sampleID==bet_oc$associatedSampleID[i]) -> a
  bet_oc$individualCount[i] <- dim(a)[1]
}


# If the 'bet_pin' list an identification for a beetle with a sampleType=='other carabid' 
# We have to assume all the beetles of that type were pinned and are listed in the 'bet_pin' table
# As per the protocol.

# This is the table that will be used to build the abundance statistics
bet_div <- as.data.frame(bind_rows(bet_cc[,1:24],bet_oc))

# Moving morphospeciesID to taxonID
for (i in 1:dim(bet_sort)[1]){
  if (bet_sort$taxonID[i]=='' & is.na(bet_sort$morphospeciesID[i])==FALSE){
    bet_sort$taxonID[i] <- bet_sort$morphospeciesID[i]
  }
}
for (i in 1:dim(bet_pin)[1]){
  if (is.na(bet_pin$taxonID[i])==TRUE & is.na(bet_pin$morphospeciesID[i])==FALSE){
    bet_pin$taxonID[i] <- bet_pin$morphospeciesID[i]
  }
  if (bet_pin$taxonID[i]=="" & bet_pin$morphospeciesID[i]!=""){
    bet_pin$taxonID[i] <- bet_pin$morphospeciesID[i]
  }
}
bet_sort %>% 
  filter(sampleType=='common carabid')-> bet_cc # a morphID is longer than 14 chars
bet_pin$sampleType <- substr(bet_pin$sampleID,nchar(bet_pin$sampleID)-4,nchar(bet_pin$sampleID)-3)
bet_pin %>% 
  filter(sampleType=='OC')->bet_oc
bet_div1 <- unique.data.frame(rbind(bet_cc[,c(1:5,10,13:14)],
                                    bet_oc[,c(2:6,9,12:13)]))
bet_div1$sampleID <- substr(bet_div1$sampleID,1,19)
rm(bet_cc,bet_oc)

for(i in 1:dim(bet_pin)[1]){
  if(unlist(strsplit(bet_pin$sampleID[i],split = '\\.'))[4]=='OC'){
    bet_pin$sampleType[i] <- 'other carabid'
  } else{
    bet_pin$sampleType[i] <- 'common carabid'
  }
}
######################################
# Adding Beetle Info To the Field Data
######################################
# Adding beetle abundance and richness; bycatch info; weather
for (i in 1:dim(bet_field)[1]){
  # adding abundance
  bet_div %>% 
    filter(plotID==bet_field$plotID[i],trapID==bet_field$trapID[i],collectDate==bet_field$collectDate[i])-> x
  bet_field$beetleAbundance[i] <- sum(x$individualCount,na.rm = TRUE)
  # adding richness (including morphospecies)
  bet_div1 %>% 
    filter(sampleID==bet_field$sampleID[i]) -> x1
  bet_field$beetleRichness[i] <-  length(unique(x1$taxonID))
  # richness excluding morphospecies
  x1 %>% 
    filter(nchar(taxonID)<14) -> x1
  bet_field$beetleRichnessNoMorphospecies[i] <- length(unique(x1$taxonID))
  
  # bycatch
  bet_sort %>% 
    filter(sampleType!='other carabid',sampleType!='common carabid',
           plotID==bet_field$plotID[i],trapID==bet_field$trapID[i],
           collectDate==bet_field$collectDate[i])-> a
  # mammal bycatch
  a %>% 
    filter(sampleType=='vert bycatch mam') -> a1
  bet_field$numMammalsCaught[i] <- sum(a1$individualCount,na.rm = TRUE)
  # amphibian/reptile bycatch
  a %>% 
    filter(sampleType=='vert bycatch herp') -> a1  
  bet_field$numHerpsCaught[i] <- sum(a1$individualCount,na.rm = TRUE)
  # invertebrate bycatch
  a %>% 
    filter(sampleType=='invert bycatch') -> a1
  bet_field$invertBycatchPresent[i] <- dim(a1)[1]  
  
  # Adding weather info; where available
  weather %>% 
    filter(siteID==bet_field$siteID[i],DATE>bet_field$setDate[i],DATE<bet_field$collectDate[i])-> w
  bet_field$prcp[i] <- sum(w$PRCP,na.rm=TRUE)
  #bet_field$tempMAX[i] <- mean(w$TMAX,na.rm=TRUE)
  #bet_field$tempMIN[i] <- mean(w$TMIN,na.rm=TRUE)
}
rm(a,a1,b1,w,x,x1,b)
